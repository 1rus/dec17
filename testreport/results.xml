<?xml version="1.0" encoding="utf-8"?><testsuite errors="4" failures="0" name="pytest" skips="0" tests="4" time="19.522"><testcase classname="scripts.test_login.Test_Login" file="scripts\test_login.py" line="15" name="test_valid_login" time="4.029729604721069"><error message="test setup failure">self = &lt;urllib.request.HTTPHandler object at 0x0599EA30&gt;
http_class = &lt;class &apos;http.client.HTTPConnection&apos;&gt;
req = &lt;selenium.webdriver.remote.remote_connection.Request object at 0x0599E610&gt;
http_conn_args = {}, host = &apos;localhost:4444&apos;
h = &lt;http.client.HTTPConnection object at 0x059B2890&gt;

    def do_open(self, http_class, req, **http_conn_args):
        &quot;&quot;&quot;Return an HTTPResponse object for the request, using http_class.
    
            http_class must implement the HTTPConnection API from http.client.
            &quot;&quot;&quot;
        host = req.host
        if not host:
            raise URLError(&apos;no host given&apos;)
    
        # will parse host:port
        h = http_class(host, timeout=req.timeout, **http_conn_args)
        h.set_debuglevel(self._debuglevel)
    
        headers = dict(req.unredirected_hdrs)
        headers.update(dict((k, v) for k, v in req.headers.items()
                            if k not in headers))
    
        # TODO(jhylton): Should this be redesigned to handle
        # persistent connections?
    
        # We want to make an HTTP/1.1 request, but the addinfourl
        # class isn&apos;t prepared to deal with a persistent connection.
        # It will try to read all remaining data from the socket,
        # which will block while the server waits for the next request.
        # So make sure the connection gets closed after the (only)
        # request.
        headers[&quot;Connection&quot;] = &quot;close&quot;
        headers = dict((name.title(), val) for name, val in headers.items())
    
        if req._tunnel_host:
            tunnel_headers = {}
            proxy_auth_hdr = &quot;Proxy-Authorization&quot;
            if proxy_auth_hdr in headers:
                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]
                # Proxy-Authorization should not be sent to origin
                # server.
                del headers[proxy_auth_hdr]
            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)
    
        try:
            try:
                h.request(req.get_method(), req.selector, req.data, headers,
&gt;                         encode_chunked=req.has_header(&apos;Transfer-encoding&apos;))

D:\Python360\lib\urllib\request.py:1318: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;http.client.HTTPConnection object at 0x059B2890&gt;, method = &apos;POST&apos;
url = &apos;/wd/hub/session&apos;
body = b&apos;{&quot;capabilities&quot;: {&quot;firstMatch&quot;: [], &quot;alwaysMatch&quot;: {&quot;browserName&quot;: &quot;chrome&quot;, &quot;version&quot;: &quot;&quot;, &quot;platform&quot;: &quot;ANY&quot;}}, &quot;desiredCapabilities&quot;: {&quot;browserName&quot;: &quot;chrome&quot;, &quot;version&quot;: &quot;&quot;, &quot;platform&quot;: &quot;ANY&quot;}}&apos;
headers = {&apos;Accept&apos;: &apos;application/json&apos;, &apos;Connection&apos;: &apos;close&apos;, &apos;Content-Length&apos;: &apos;196&apos;, &apos;Content-Type&apos;: &apos;application/json;charset=UTF-8&apos;, ...}

    def request(self, method, url, body=None, headers={}, *,
                encode_chunked=False):
        &quot;&quot;&quot;Send a complete request to the server.&quot;&quot;&quot;
&gt;       self._send_request(method, url, body, headers, encode_chunked)

D:\Python360\lib\http\client.py:1239: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;http.client.HTTPConnection object at 0x059B2890&gt;, method = &apos;POST&apos;
url = &apos;/wd/hub/session&apos;
body = b&apos;{&quot;capabilities&quot;: {&quot;firstMatch&quot;: [], &quot;alwaysMatch&quot;: {&quot;browserName&quot;: &quot;chrome&quot;, &quot;version&quot;: &quot;&quot;, &quot;platform&quot;: &quot;ANY&quot;}}, &quot;desiredCapabilities&quot;: {&quot;browserName&quot;: &quot;chrome&quot;, &quot;version&quot;: &quot;&quot;, &quot;platform&quot;: &quot;ANY&quot;}}&apos;
headers = {&apos;Accept&apos;: &apos;application/json&apos;, &apos;Connection&apos;: &apos;close&apos;, &apos;Content-Length&apos;: &apos;196&apos;, &apos;Content-Type&apos;: &apos;application/json;charset=UTF-8&apos;, ...}
encode_chunked = False

    def _send_request(self, method, url, body, headers, encode_chunked):
        # Honor explicitly requested Host: and Accept-Encoding: headers.
        header_names = frozenset(k.lower() for k in headers)
        skips = {}
        if &apos;host&apos; in header_names:
            skips[&apos;skip_host&apos;] = 1
        if &apos;accept-encoding&apos; in header_names:
            skips[&apos;skip_accept_encoding&apos;] = 1
    
        self.putrequest(method, url, **skips)
    
        # chunked encoding will happen if HTTP/1.1 is used and either
        # the caller passes encode_chunked=True or the following
        # conditions hold:
        # 1. content-length has not been explicitly set
        # 2. the body is a file or iterable, but not a str or bytes-like
        # 3. Transfer-Encoding has NOT been explicitly set by the caller
    
        if &apos;content-length&apos; not in header_names:
            # only chunk body if not explicitly set for backwards
            # compatibility, assuming the client code is already handling the
            # chunking
            if &apos;transfer-encoding&apos; not in header_names:
                # if content-length cannot be automatically determined, fall
                # back to chunked encoding
                encode_chunked = False
                content_length = self._get_content_length(body, method)
                if content_length is None:
                    if body is not None:
                        if self.debuglevel &gt; 0:
                            print(&apos;Unable to determine size of %r&apos; % body)
                        encode_chunked = True
                        self.putheader(&apos;Transfer-Encoding&apos;, &apos;chunked&apos;)
                else:
                    self.putheader(&apos;Content-Length&apos;, str(content_length))
        else:
            encode_chunked = False
    
        for hdr, value in headers.items():
            self.putheader(hdr, value)
        if isinstance(body, str):
            # RFC 2616 Section 3.7.1 says that text default has a
            # default charset of iso-8859-1.
            body = _encode(body, &apos;body&apos;)
&gt;       self.endheaders(body, encode_chunked=encode_chunked)

D:\Python360\lib\http\client.py:1285: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;http.client.HTTPConnection object at 0x059B2890&gt;
message_body = b&apos;{&quot;capabilities&quot;: {&quot;firstMatch&quot;: [], &quot;alwaysMatch&quot;: {&quot;browserName&quot;: &quot;chrome&quot;, &quot;version&quot;: &quot;&quot;, &quot;platform&quot;: &quot;ANY&quot;}}, &quot;desiredCapabilities&quot;: {&quot;browserName&quot;: &quot;chrome&quot;, &quot;version&quot;: &quot;&quot;, &quot;platform&quot;: &quot;ANY&quot;}}&apos;

    def endheaders(self, message_body=None, *, encode_chunked=False):
        &quot;&quot;&quot;Indicate that the last header line has been sent to the server.
    
            This method sends the request to the server.  The optional message_body
            argument can be used to pass a message body associated with the
            request.
            &quot;&quot;&quot;
        if self.__state == _CS_REQ_STARTED:
            self.__state = _CS_REQ_SENT
        else:
            raise CannotSendHeader()
&gt;       self._send_output(message_body, encode_chunked=encode_chunked)

D:\Python360\lib\http\client.py:1234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;http.client.HTTPConnection object at 0x059B2890&gt;
message_body = b&apos;{&quot;capabilities&quot;: {&quot;firstMatch&quot;: [], &quot;alwaysMatch&quot;: {&quot;browserName&quot;: &quot;chrome&quot;, &quot;version&quot;: &quot;&quot;, &quot;platform&quot;: &quot;ANY&quot;}}, &quot;desiredCapabilities&quot;: {&quot;browserName&quot;: &quot;chrome&quot;, &quot;version&quot;: &quot;&quot;, &quot;platform&quot;: &quot;ANY&quot;}}&apos;
encode_chunked = False

    def _send_output(self, message_body=None, encode_chunked=False):
        &quot;&quot;&quot;Send the currently buffered request and clear the buffer.
    
            Appends an extra \\r\\n to the buffer.
            A message_body may be specified, to be appended to the request.
            &quot;&quot;&quot;
        self._buffer.extend((b&quot;&quot;, b&quot;&quot;))
        msg = b&quot;\r\n&quot;.join(self._buffer)
        del self._buffer[:]
&gt;       self.send(msg)

D:\Python360\lib\http\client.py:1026: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;http.client.HTTPConnection object at 0x059B2890&gt;
data = b&apos;POST /wd/hub/session HTTP/1.1\r\nAccept-Encoding: identity\r\nContent-Length: 196\r\nHost: localhost:4444\r\nAccept:...tion/json\r\nContent-Type: application/json;charset=UTF-8\r\nUser-Agent: Python http auth\r\nConnection: close\r\n\r\n&apos;

    def send(self, data):
        &quot;&quot;&quot;Send `data&apos; to the server.
            ``data`` can be a string object, a bytes object, an array object, a
            file-like object that supports a .read() method, or an iterable object.
            &quot;&quot;&quot;
    
        if self.sock is None:
            if self.auto_open:
&gt;               self.connect()

D:\Python360\lib\http\client.py:964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;http.client.HTTPConnection object at 0x059B2890&gt;

    def connect(self):
        &quot;&quot;&quot;Connect to the host and port specified in __init__.&quot;&quot;&quot;
        self.sock = self._create_connection(
&gt;           (self.host,self.port), self.timeout, self.source_address)

D:\Python360\lib\http\client.py:936: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

address = (&apos;localhost&apos;, 4444), timeout = &lt;object object at 0x027FAC70&gt;
source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        &quot;&quot;&quot;Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of &apos;&apos; or port 0 tells the OS to use the default.
        &quot;&quot;&quot;
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
                sock.connect(sa)
                return sock
    
            except error as _:
                err = _
                if sock is not None:
                    sock.close()
    
        if err is not None:
&gt;           raise err

D:\Python360\lib\socket.py:722: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

address = (&apos;localhost&apos;, 4444), timeout = &lt;object object at 0x027FAC70&gt;
source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        &quot;&quot;&quot;Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of &apos;&apos; or port 0 tells the OS to use the default.
        &quot;&quot;&quot;
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
&gt;               sock.connect(sa)
E               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it

D:\Python360\lib\socket.py:713: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = &lt;test_login.Test_Login object at 0x059B23F0&gt;
method = &lt;bound method Test_Login.test_valid_login of &lt;test_login.Test_Login object at 0x059B23F0&gt;&gt;

    def setup_method(self, method):
        self.current_method = method.__name__
        c = Config()
        self.config = c.prepare()
        browser_conf = self.config[&quot;browser&quot;]
&gt;       self.browser = browser.Browser(browser_conf, self.config)

base\FrameTestCase.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
browser.py:85: in __init__
    self.driver = SframeWebdriver(desired_capabilities=caps,command_executor=com_exe,browser_profile=profile)
framedriver.py:11: in __init__
    super(SframeWebdriver, self).__init__(**kwargs)
D:\Python360\lib\site-packages\selenium\webdriver\remote\webdriver.py:98: in __init__
    self.start_session(desired_capabilities, browser_profile)
D:\Python360\lib\site-packages\selenium\webdriver\remote\webdriver.py:188: in start_session
    response = self.execute(Command.NEW_SESSION, parameters)
D:\Python360\lib\site-packages\selenium\webdriver\remote\webdriver.py:250: in execute
    response = self.command_executor.execute(driver_command, params)
D:\Python360\lib\site-packages\selenium\webdriver\remote\remote_connection.py:464: in execute
    return self._request(command_info[0], url, body=data)
D:\Python360\lib\site-packages\selenium\webdriver\remote\remote_connection.py:526: in _request
    resp = opener.open(request, timeout=self._timeout)
D:\Python360\lib\urllib\request.py:526: in open
    response = self._open(req, data)
D:\Python360\lib\urllib\request.py:544: in _open
    &apos;_open&apos;, req)
D:\Python360\lib\urllib\request.py:504: in _call_chain
    result = func(*args)
D:\Python360\lib\urllib\request.py:1346: in http_open
    return self.do_open(http.client.HTTPConnection, req)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;urllib.request.HTTPHandler object at 0x0599EA30&gt;
http_class = &lt;class &apos;http.client.HTTPConnection&apos;&gt;
req = &lt;selenium.webdriver.remote.remote_connection.Request object at 0x0599E610&gt;
http_conn_args = {}, host = &apos;localhost:4444&apos;
h = &lt;http.client.HTTPConnection object at 0x059B2890&gt;

    def do_open(self, http_class, req, **http_conn_args):
        &quot;&quot;&quot;Return an HTTPResponse object for the request, using http_class.
    
            http_class must implement the HTTPConnection API from http.client.
            &quot;&quot;&quot;
        host = req.host
        if not host:
            raise URLError(&apos;no host given&apos;)
    
        # will parse host:port
        h = http_class(host, timeout=req.timeout, **http_conn_args)
        h.set_debuglevel(self._debuglevel)
    
        headers = dict(req.unredirected_hdrs)
        headers.update(dict((k, v) for k, v in req.headers.items()
                            if k not in headers))
    
        # TODO(jhylton): Should this be redesigned to handle
        # persistent connections?
    
        # We want to make an HTTP/1.1 request, but the addinfourl
        # class isn&apos;t prepared to deal with a persistent connection.
        # It will try to read all remaining data from the socket,
        # which will block while the server waits for the next request.
        # So make sure the connection gets closed after the (only)
        # request.
        headers[&quot;Connection&quot;] = &quot;close&quot;
        headers = dict((name.title(), val) for name, val in headers.items())
    
        if req._tunnel_host:
            tunnel_headers = {}
            proxy_auth_hdr = &quot;Proxy-Authorization&quot;
            if proxy_auth_hdr in headers:
                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]
                # Proxy-Authorization should not be sent to origin
                # server.
                del headers[proxy_auth_hdr]
            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)
    
        try:
            try:
                h.request(req.get_method(), req.selector, req.data, headers,
                          encode_chunked=req.has_header(&apos;Transfer-encoding&apos;))
            except OSError as err: # timeout error
&gt;               raise URLError(err)
E               urllib.error.URLError: &lt;urlopen error [WinError 10061] No connection could be made because the target machine actively refused it&gt;

D:\Python360\lib\urllib\request.py:1320: URLError</error><system-out>{&apos;version&apos;: 1, &apos;disable_existing_loggers&apos;: False, &apos;formatters&apos;: {&apos;simple&apos;: {&apos;format&apos;: &apos;%(asctime)s - %(name)s - %(levelname)s - %(message)s&apos;}}, &apos;handlers&apos;: {&apos;console&apos;: {&apos;class&apos;: &apos;logging.StreamHandler&apos;, &apos;level&apos;: &apos;DEBUG&apos;, &apos;formatter&apos;: &apos;simple&apos;, &apos;stream&apos;: &apos;ext://sys.stdout&apos;}, &apos;info_file_handler&apos;: {&apos;class&apos;: &apos;logging.handlers.RotatingFileHandler&apos;, &apos;level&apos;: &apos;INFO&apos;, &apos;formatter&apos;: &apos;simple&apos;, &apos;filename&apos;: &apos;D:\\dec17\\output\\2017-12-19-15-29-24\\logs\\info.log&apos;, &apos;maxBytes&apos;: 10485760, &apos;backupCount&apos;: 20, &apos;encoding&apos;: &apos;utf8&apos;}, &apos;error_file_handler&apos;: {&apos;class&apos;: &apos;logging.handlers.RotatingFileHandler&apos;, &apos;level&apos;: &apos;ERROR&apos;, &apos;formatter&apos;: &apos;simple&apos;, &apos;filename&apos;: &apos;D:\\dec17\\output\\2017-12-19-15-29-24\\logs\\errors.log&apos;, &apos;maxBytes&apos;: 10485760, &apos;backupCount&apos;: 20, &apos;encoding&apos;: &apos;utf8&apos;}}, &apos;loggers&apos;: {&apos;my_module&apos;: {&apos;level&apos;: &apos;ERROR&apos;, &apos;handlers&apos;: [&apos;console&apos;], &apos;propagate&apos;: False}}, &apos;root&apos;: {&apos;level&apos;: &apos;INFO&apos;, &apos;handlers&apos;: [&apos;console&apos;, &apos;info_file_handler&apos;, &apos;error_file_handler&apos;]}}
browser init
{&apos;type&apos;: &apos;chrome&apos;, &apos;profiles&apos;: {&apos;darwin&apos;: None, &apos;profile&apos;: None}, &apos;grid filters&apos;: {&apos;platform&apos;: &apos;mac&apos;, &apos;version&apos;: &apos;23.0.1&apos;}}
2017-12-19 15:29:26,730 - selenium.webdriver.remote.remote_connection - INFO - Could not get IP address for host: localhost
</system-out></testcase><testcase classname="scripts.test_login.Test_Login" file="scripts\test_login.py" line="22" name="test_logout" time="4.026057243347168"><error message="test setup failure">self = &lt;urllib.request.HTTPHandler object at 0x05C45C30&gt;
http_class = &lt;class &apos;http.client.HTTPConnection&apos;&gt;
req = &lt;selenium.webdriver.remote.remote_connection.Request object at 0x05C45530&gt;
http_conn_args = {}, host = &apos;localhost:4444&apos;
h = &lt;http.client.HTTPConnection object at 0x05C45F70&gt;

    def do_open(self, http_class, req, **http_conn_args):
        &quot;&quot;&quot;Return an HTTPResponse object for the request, using http_class.
    
            http_class must implement the HTTPConnection API from http.client.
            &quot;&quot;&quot;
        host = req.host
        if not host:
            raise URLError(&apos;no host given&apos;)
    
        # will parse host:port
        h = http_class(host, timeout=req.timeout, **http_conn_args)
        h.set_debuglevel(self._debuglevel)
    
        headers = dict(req.unredirected_hdrs)
        headers.update(dict((k, v) for k, v in req.headers.items()
                            if k not in headers))
    
        # TODO(jhylton): Should this be redesigned to handle
        # persistent connections?
    
        # We want to make an HTTP/1.1 request, but the addinfourl
        # class isn&apos;t prepared to deal with a persistent connection.
        # It will try to read all remaining data from the socket,
        # which will block while the server waits for the next request.
        # So make sure the connection gets closed after the (only)
        # request.
        headers[&quot;Connection&quot;] = &quot;close&quot;
        headers = dict((name.title(), val) for name, val in headers.items())
    
        if req._tunnel_host:
            tunnel_headers = {}
            proxy_auth_hdr = &quot;Proxy-Authorization&quot;
            if proxy_auth_hdr in headers:
                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]
                # Proxy-Authorization should not be sent to origin
                # server.
                del headers[proxy_auth_hdr]
            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)
    
        try:
            try:
                h.request(req.get_method(), req.selector, req.data, headers,
&gt;                         encode_chunked=req.has_header(&apos;Transfer-encoding&apos;))

D:\Python360\lib\urllib\request.py:1318: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;http.client.HTTPConnection object at 0x05C45F70&gt;, method = &apos;POST&apos;
url = &apos;/wd/hub/session&apos;
body = b&apos;{&quot;capabilities&quot;: {&quot;firstMatch&quot;: [], &quot;alwaysMatch&quot;: {&quot;browserName&quot;: &quot;chrome&quot;, &quot;version&quot;: &quot;&quot;, &quot;platform&quot;: &quot;ANY&quot;}}, &quot;desiredCapabilities&quot;: {&quot;browserName&quot;: &quot;chrome&quot;, &quot;version&quot;: &quot;&quot;, &quot;platform&quot;: &quot;ANY&quot;}}&apos;
headers = {&apos;Accept&apos;: &apos;application/json&apos;, &apos;Connection&apos;: &apos;close&apos;, &apos;Content-Length&apos;: &apos;196&apos;, &apos;Content-Type&apos;: &apos;application/json;charset=UTF-8&apos;, ...}

    def request(self, method, url, body=None, headers={}, *,
                encode_chunked=False):
        &quot;&quot;&quot;Send a complete request to the server.&quot;&quot;&quot;
&gt;       self._send_request(method, url, body, headers, encode_chunked)

D:\Python360\lib\http\client.py:1239: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;http.client.HTTPConnection object at 0x05C45F70&gt;, method = &apos;POST&apos;
url = &apos;/wd/hub/session&apos;
body = b&apos;{&quot;capabilities&quot;: {&quot;firstMatch&quot;: [], &quot;alwaysMatch&quot;: {&quot;browserName&quot;: &quot;chrome&quot;, &quot;version&quot;: &quot;&quot;, &quot;platform&quot;: &quot;ANY&quot;}}, &quot;desiredCapabilities&quot;: {&quot;browserName&quot;: &quot;chrome&quot;, &quot;version&quot;: &quot;&quot;, &quot;platform&quot;: &quot;ANY&quot;}}&apos;
headers = {&apos;Accept&apos;: &apos;application/json&apos;, &apos;Connection&apos;: &apos;close&apos;, &apos;Content-Length&apos;: &apos;196&apos;, &apos;Content-Type&apos;: &apos;application/json;charset=UTF-8&apos;, ...}
encode_chunked = False

    def _send_request(self, method, url, body, headers, encode_chunked):
        # Honor explicitly requested Host: and Accept-Encoding: headers.
        header_names = frozenset(k.lower() for k in headers)
        skips = {}
        if &apos;host&apos; in header_names:
            skips[&apos;skip_host&apos;] = 1
        if &apos;accept-encoding&apos; in header_names:
            skips[&apos;skip_accept_encoding&apos;] = 1
    
        self.putrequest(method, url, **skips)
    
        # chunked encoding will happen if HTTP/1.1 is used and either
        # the caller passes encode_chunked=True or the following
        # conditions hold:
        # 1. content-length has not been explicitly set
        # 2. the body is a file or iterable, but not a str or bytes-like
        # 3. Transfer-Encoding has NOT been explicitly set by the caller
    
        if &apos;content-length&apos; not in header_names:
            # only chunk body if not explicitly set for backwards
            # compatibility, assuming the client code is already handling the
            # chunking
            if &apos;transfer-encoding&apos; not in header_names:
                # if content-length cannot be automatically determined, fall
                # back to chunked encoding
                encode_chunked = False
                content_length = self._get_content_length(body, method)
                if content_length is None:
                    if body is not None:
                        if self.debuglevel &gt; 0:
                            print(&apos;Unable to determine size of %r&apos; % body)
                        encode_chunked = True
                        self.putheader(&apos;Transfer-Encoding&apos;, &apos;chunked&apos;)
                else:
                    self.putheader(&apos;Content-Length&apos;, str(content_length))
        else:
            encode_chunked = False
    
        for hdr, value in headers.items():
            self.putheader(hdr, value)
        if isinstance(body, str):
            # RFC 2616 Section 3.7.1 says that text default has a
            # default charset of iso-8859-1.
            body = _encode(body, &apos;body&apos;)
&gt;       self.endheaders(body, encode_chunked=encode_chunked)

D:\Python360\lib\http\client.py:1285: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;http.client.HTTPConnection object at 0x05C45F70&gt;
message_body = b&apos;{&quot;capabilities&quot;: {&quot;firstMatch&quot;: [], &quot;alwaysMatch&quot;: {&quot;browserName&quot;: &quot;chrome&quot;, &quot;version&quot;: &quot;&quot;, &quot;platform&quot;: &quot;ANY&quot;}}, &quot;desiredCapabilities&quot;: {&quot;browserName&quot;: &quot;chrome&quot;, &quot;version&quot;: &quot;&quot;, &quot;platform&quot;: &quot;ANY&quot;}}&apos;

    def endheaders(self, message_body=None, *, encode_chunked=False):
        &quot;&quot;&quot;Indicate that the last header line has been sent to the server.
    
            This method sends the request to the server.  The optional message_body
            argument can be used to pass a message body associated with the
            request.
            &quot;&quot;&quot;
        if self.__state == _CS_REQ_STARTED:
            self.__state = _CS_REQ_SENT
        else:
            raise CannotSendHeader()
&gt;       self._send_output(message_body, encode_chunked=encode_chunked)

D:\Python360\lib\http\client.py:1234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;http.client.HTTPConnection object at 0x05C45F70&gt;
message_body = b&apos;{&quot;capabilities&quot;: {&quot;firstMatch&quot;: [], &quot;alwaysMatch&quot;: {&quot;browserName&quot;: &quot;chrome&quot;, &quot;version&quot;: &quot;&quot;, &quot;platform&quot;: &quot;ANY&quot;}}, &quot;desiredCapabilities&quot;: {&quot;browserName&quot;: &quot;chrome&quot;, &quot;version&quot;: &quot;&quot;, &quot;platform&quot;: &quot;ANY&quot;}}&apos;
encode_chunked = False

    def _send_output(self, message_body=None, encode_chunked=False):
        &quot;&quot;&quot;Send the currently buffered request and clear the buffer.
    
            Appends an extra \\r\\n to the buffer.
            A message_body may be specified, to be appended to the request.
            &quot;&quot;&quot;
        self._buffer.extend((b&quot;&quot;, b&quot;&quot;))
        msg = b&quot;\r\n&quot;.join(self._buffer)
        del self._buffer[:]
&gt;       self.send(msg)

D:\Python360\lib\http\client.py:1026: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;http.client.HTTPConnection object at 0x05C45F70&gt;
data = b&apos;POST /wd/hub/session HTTP/1.1\r\nAccept-Encoding: identity\r\nContent-Length: 196\r\nHost: localhost:4444\r\nAccept:...tion/json\r\nContent-Type: application/json;charset=UTF-8\r\nUser-Agent: Python http auth\r\nConnection: close\r\n\r\n&apos;

    def send(self, data):
        &quot;&quot;&quot;Send `data&apos; to the server.
            ``data`` can be a string object, a bytes object, an array object, a
            file-like object that supports a .read() method, or an iterable object.
            &quot;&quot;&quot;
    
        if self.sock is None:
            if self.auto_open:
&gt;               self.connect()

D:\Python360\lib\http\client.py:964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;http.client.HTTPConnection object at 0x05C45F70&gt;

    def connect(self):
        &quot;&quot;&quot;Connect to the host and port specified in __init__.&quot;&quot;&quot;
        self.sock = self._create_connection(
&gt;           (self.host,self.port), self.timeout, self.source_address)

D:\Python360\lib\http\client.py:936: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

address = (&apos;localhost&apos;, 4444), timeout = &lt;object object at 0x027FAC70&gt;
source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        &quot;&quot;&quot;Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of &apos;&apos; or port 0 tells the OS to use the default.
        &quot;&quot;&quot;
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
                sock.connect(sa)
                return sock
    
            except error as _:
                err = _
                if sock is not None:
                    sock.close()
    
        if err is not None:
&gt;           raise err

D:\Python360\lib\socket.py:722: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

address = (&apos;localhost&apos;, 4444), timeout = &lt;object object at 0x027FAC70&gt;
source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        &quot;&quot;&quot;Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of &apos;&apos; or port 0 tells the OS to use the default.
        &quot;&quot;&quot;
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
&gt;               sock.connect(sa)
E               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it

D:\Python360\lib\socket.py:713: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = &lt;test_login.Test_Login object at 0x05CEA390&gt;
method = &lt;bound method Test_Login.test_logout of &lt;test_login.Test_Login object at 0x05CEA390&gt;&gt;

    def setup_method(self, method):
        self.current_method = method.__name__
        c = Config()
        self.config = c.prepare()
        browser_conf = self.config[&quot;browser&quot;]
&gt;       self.browser = browser.Browser(browser_conf, self.config)

base\FrameTestCase.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
browser.py:85: in __init__
    self.driver = SframeWebdriver(desired_capabilities=caps,command_executor=com_exe,browser_profile=profile)
framedriver.py:11: in __init__
    super(SframeWebdriver, self).__init__(**kwargs)
D:\Python360\lib\site-packages\selenium\webdriver\remote\webdriver.py:98: in __init__
    self.start_session(desired_capabilities, browser_profile)
D:\Python360\lib\site-packages\selenium\webdriver\remote\webdriver.py:188: in start_session
    response = self.execute(Command.NEW_SESSION, parameters)
D:\Python360\lib\site-packages\selenium\webdriver\remote\webdriver.py:250: in execute
    response = self.command_executor.execute(driver_command, params)
D:\Python360\lib\site-packages\selenium\webdriver\remote\remote_connection.py:464: in execute
    return self._request(command_info[0], url, body=data)
D:\Python360\lib\site-packages\selenium\webdriver\remote\remote_connection.py:526: in _request
    resp = opener.open(request, timeout=self._timeout)
D:\Python360\lib\urllib\request.py:526: in open
    response = self._open(req, data)
D:\Python360\lib\urllib\request.py:544: in _open
    &apos;_open&apos;, req)
D:\Python360\lib\urllib\request.py:504: in _call_chain
    result = func(*args)
D:\Python360\lib\urllib\request.py:1346: in http_open
    return self.do_open(http.client.HTTPConnection, req)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;urllib.request.HTTPHandler object at 0x05C45C30&gt;
http_class = &lt;class &apos;http.client.HTTPConnection&apos;&gt;
req = &lt;selenium.webdriver.remote.remote_connection.Request object at 0x05C45530&gt;
http_conn_args = {}, host = &apos;localhost:4444&apos;
h = &lt;http.client.HTTPConnection object at 0x05C45F70&gt;

    def do_open(self, http_class, req, **http_conn_args):
        &quot;&quot;&quot;Return an HTTPResponse object for the request, using http_class.
    
            http_class must implement the HTTPConnection API from http.client.
            &quot;&quot;&quot;
        host = req.host
        if not host:
            raise URLError(&apos;no host given&apos;)
    
        # will parse host:port
        h = http_class(host, timeout=req.timeout, **http_conn_args)
        h.set_debuglevel(self._debuglevel)
    
        headers = dict(req.unredirected_hdrs)
        headers.update(dict((k, v) for k, v in req.headers.items()
                            if k not in headers))
    
        # TODO(jhylton): Should this be redesigned to handle
        # persistent connections?
    
        # We want to make an HTTP/1.1 request, but the addinfourl
        # class isn&apos;t prepared to deal with a persistent connection.
        # It will try to read all remaining data from the socket,
        # which will block while the server waits for the next request.
        # So make sure the connection gets closed after the (only)
        # request.
        headers[&quot;Connection&quot;] = &quot;close&quot;
        headers = dict((name.title(), val) for name, val in headers.items())
    
        if req._tunnel_host:
            tunnel_headers = {}
            proxy_auth_hdr = &quot;Proxy-Authorization&quot;
            if proxy_auth_hdr in headers:
                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]
                # Proxy-Authorization should not be sent to origin
                # server.
                del headers[proxy_auth_hdr]
            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)
    
        try:
            try:
                h.request(req.get_method(), req.selector, req.data, headers,
                          encode_chunked=req.has_header(&apos;Transfer-encoding&apos;))
            except OSError as err: # timeout error
&gt;               raise URLError(err)
E               urllib.error.URLError: &lt;urlopen error [WinError 10061] No connection could be made because the target machine actively refused it&gt;

D:\Python360\lib\urllib\request.py:1320: URLError</error><system-out>{&apos;version&apos;: 1, &apos;disable_existing_loggers&apos;: False, &apos;formatters&apos;: {&apos;simple&apos;: {&apos;format&apos;: &apos;%(asctime)s - %(name)s - %(levelname)s - %(message)s&apos;}}, &apos;handlers&apos;: {&apos;console&apos;: {&apos;class&apos;: &apos;logging.StreamHandler&apos;, &apos;level&apos;: &apos;DEBUG&apos;, &apos;formatter&apos;: &apos;simple&apos;, &apos;stream&apos;: &apos;ext://sys.stdout&apos;}, &apos;info_file_handler&apos;: {&apos;class&apos;: &apos;logging.handlers.RotatingFileHandler&apos;, &apos;level&apos;: &apos;INFO&apos;, &apos;formatter&apos;: &apos;simple&apos;, &apos;filename&apos;: &apos;D:\\dec17\\output\\2017-12-19-15-29-29\\logs\\info.log&apos;, &apos;maxBytes&apos;: 10485760, &apos;backupCount&apos;: 20, &apos;encoding&apos;: &apos;utf8&apos;}, &apos;error_file_handler&apos;: {&apos;class&apos;: &apos;logging.handlers.RotatingFileHandler&apos;, &apos;level&apos;: &apos;ERROR&apos;, &apos;formatter&apos;: &apos;simple&apos;, &apos;filename&apos;: &apos;D:\\dec17\\output\\2017-12-19-15-29-29\\logs\\errors.log&apos;, &apos;maxBytes&apos;: 10485760, &apos;backupCount&apos;: 20, &apos;encoding&apos;: &apos;utf8&apos;}}, &apos;loggers&apos;: {&apos;my_module&apos;: {&apos;level&apos;: &apos;ERROR&apos;, &apos;handlers&apos;: [&apos;console&apos;], &apos;propagate&apos;: False}}, &apos;root&apos;: {&apos;level&apos;: &apos;INFO&apos;, &apos;handlers&apos;: [&apos;console&apos;, &apos;info_file_handler&apos;, &apos;error_file_handler&apos;]}}
browser init
{&apos;type&apos;: &apos;chrome&apos;, &apos;profiles&apos;: {&apos;darwin&apos;: None, &apos;profile&apos;: None}, &apos;grid filters&apos;: {&apos;platform&apos;: &apos;mac&apos;, &apos;version&apos;: &apos;23.0.1&apos;}}
2017-12-19 15:29:31,568 - selenium.webdriver.remote.remote_connection - INFO - Could not get IP address for host: localhost
</system-out></testcase><testcase classname="scripts.test_login.Test_Login" file="scripts\test_login.py" line="29" name="test_empty_password" time="4.025469541549683"><error message="test setup failure">self = &lt;urllib.request.HTTPHandler object at 0x061EF7F0&gt;
http_class = &lt;class &apos;http.client.HTTPConnection&apos;&gt;
req = &lt;selenium.webdriver.remote.remote_connection.Request object at 0x061EF390&gt;
http_conn_args = {}, host = &apos;localhost:4444&apos;
h = &lt;http.client.HTTPConnection object at 0x061EF650&gt;

    def do_open(self, http_class, req, **http_conn_args):
        &quot;&quot;&quot;Return an HTTPResponse object for the request, using http_class.
    
            http_class must implement the HTTPConnection API from http.client.
            &quot;&quot;&quot;
        host = req.host
        if not host:
            raise URLError(&apos;no host given&apos;)
    
        # will parse host:port
        h = http_class(host, timeout=req.timeout, **http_conn_args)
        h.set_debuglevel(self._debuglevel)
    
        headers = dict(req.unredirected_hdrs)
        headers.update(dict((k, v) for k, v in req.headers.items()
                            if k not in headers))
    
        # TODO(jhylton): Should this be redesigned to handle
        # persistent connections?
    
        # We want to make an HTTP/1.1 request, but the addinfourl
        # class isn&apos;t prepared to deal with a persistent connection.
        # It will try to read all remaining data from the socket,
        # which will block while the server waits for the next request.
        # So make sure the connection gets closed after the (only)
        # request.
        headers[&quot;Connection&quot;] = &quot;close&quot;
        headers = dict((name.title(), val) for name, val in headers.items())
    
        if req._tunnel_host:
            tunnel_headers = {}
            proxy_auth_hdr = &quot;Proxy-Authorization&quot;
            if proxy_auth_hdr in headers:
                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]
                # Proxy-Authorization should not be sent to origin
                # server.
                del headers[proxy_auth_hdr]
            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)
    
        try:
            try:
                h.request(req.get_method(), req.selector, req.data, headers,
&gt;                         encode_chunked=req.has_header(&apos;Transfer-encoding&apos;))

D:\Python360\lib\urllib\request.py:1318: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;http.client.HTTPConnection object at 0x061EF650&gt;, method = &apos;POST&apos;
url = &apos;/wd/hub/session&apos;
body = b&apos;{&quot;capabilities&quot;: {&quot;firstMatch&quot;: [], &quot;alwaysMatch&quot;: {&quot;browserName&quot;: &quot;chrome&quot;, &quot;version&quot;: &quot;&quot;, &quot;platform&quot;: &quot;ANY&quot;}}, &quot;desiredCapabilities&quot;: {&quot;browserName&quot;: &quot;chrome&quot;, &quot;version&quot;: &quot;&quot;, &quot;platform&quot;: &quot;ANY&quot;}}&apos;
headers = {&apos;Accept&apos;: &apos;application/json&apos;, &apos;Connection&apos;: &apos;close&apos;, &apos;Content-Length&apos;: &apos;196&apos;, &apos;Content-Type&apos;: &apos;application/json;charset=UTF-8&apos;, ...}

    def request(self, method, url, body=None, headers={}, *,
                encode_chunked=False):
        &quot;&quot;&quot;Send a complete request to the server.&quot;&quot;&quot;
&gt;       self._send_request(method, url, body, headers, encode_chunked)

D:\Python360\lib\http\client.py:1239: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;http.client.HTTPConnection object at 0x061EF650&gt;, method = &apos;POST&apos;
url = &apos;/wd/hub/session&apos;
body = b&apos;{&quot;capabilities&quot;: {&quot;firstMatch&quot;: [], &quot;alwaysMatch&quot;: {&quot;browserName&quot;: &quot;chrome&quot;, &quot;version&quot;: &quot;&quot;, &quot;platform&quot;: &quot;ANY&quot;}}, &quot;desiredCapabilities&quot;: {&quot;browserName&quot;: &quot;chrome&quot;, &quot;version&quot;: &quot;&quot;, &quot;platform&quot;: &quot;ANY&quot;}}&apos;
headers = {&apos;Accept&apos;: &apos;application/json&apos;, &apos;Connection&apos;: &apos;close&apos;, &apos;Content-Length&apos;: &apos;196&apos;, &apos;Content-Type&apos;: &apos;application/json;charset=UTF-8&apos;, ...}
encode_chunked = False

    def _send_request(self, method, url, body, headers, encode_chunked):
        # Honor explicitly requested Host: and Accept-Encoding: headers.
        header_names = frozenset(k.lower() for k in headers)
        skips = {}
        if &apos;host&apos; in header_names:
            skips[&apos;skip_host&apos;] = 1
        if &apos;accept-encoding&apos; in header_names:
            skips[&apos;skip_accept_encoding&apos;] = 1
    
        self.putrequest(method, url, **skips)
    
        # chunked encoding will happen if HTTP/1.1 is used and either
        # the caller passes encode_chunked=True or the following
        # conditions hold:
        # 1. content-length has not been explicitly set
        # 2. the body is a file or iterable, but not a str or bytes-like
        # 3. Transfer-Encoding has NOT been explicitly set by the caller
    
        if &apos;content-length&apos; not in header_names:
            # only chunk body if not explicitly set for backwards
            # compatibility, assuming the client code is already handling the
            # chunking
            if &apos;transfer-encoding&apos; not in header_names:
                # if content-length cannot be automatically determined, fall
                # back to chunked encoding
                encode_chunked = False
                content_length = self._get_content_length(body, method)
                if content_length is None:
                    if body is not None:
                        if self.debuglevel &gt; 0:
                            print(&apos;Unable to determine size of %r&apos; % body)
                        encode_chunked = True
                        self.putheader(&apos;Transfer-Encoding&apos;, &apos;chunked&apos;)
                else:
                    self.putheader(&apos;Content-Length&apos;, str(content_length))
        else:
            encode_chunked = False
    
        for hdr, value in headers.items():
            self.putheader(hdr, value)
        if isinstance(body, str):
            # RFC 2616 Section 3.7.1 says that text default has a
            # default charset of iso-8859-1.
            body = _encode(body, &apos;body&apos;)
&gt;       self.endheaders(body, encode_chunked=encode_chunked)

D:\Python360\lib\http\client.py:1285: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;http.client.HTTPConnection object at 0x061EF650&gt;
message_body = b&apos;{&quot;capabilities&quot;: {&quot;firstMatch&quot;: [], &quot;alwaysMatch&quot;: {&quot;browserName&quot;: &quot;chrome&quot;, &quot;version&quot;: &quot;&quot;, &quot;platform&quot;: &quot;ANY&quot;}}, &quot;desiredCapabilities&quot;: {&quot;browserName&quot;: &quot;chrome&quot;, &quot;version&quot;: &quot;&quot;, &quot;platform&quot;: &quot;ANY&quot;}}&apos;

    def endheaders(self, message_body=None, *, encode_chunked=False):
        &quot;&quot;&quot;Indicate that the last header line has been sent to the server.
    
            This method sends the request to the server.  The optional message_body
            argument can be used to pass a message body associated with the
            request.
            &quot;&quot;&quot;
        if self.__state == _CS_REQ_STARTED:
            self.__state = _CS_REQ_SENT
        else:
            raise CannotSendHeader()
&gt;       self._send_output(message_body, encode_chunked=encode_chunked)

D:\Python360\lib\http\client.py:1234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;http.client.HTTPConnection object at 0x061EF650&gt;
message_body = b&apos;{&quot;capabilities&quot;: {&quot;firstMatch&quot;: [], &quot;alwaysMatch&quot;: {&quot;browserName&quot;: &quot;chrome&quot;, &quot;version&quot;: &quot;&quot;, &quot;platform&quot;: &quot;ANY&quot;}}, &quot;desiredCapabilities&quot;: {&quot;browserName&quot;: &quot;chrome&quot;, &quot;version&quot;: &quot;&quot;, &quot;platform&quot;: &quot;ANY&quot;}}&apos;
encode_chunked = False

    def _send_output(self, message_body=None, encode_chunked=False):
        &quot;&quot;&quot;Send the currently buffered request and clear the buffer.
    
            Appends an extra \\r\\n to the buffer.
            A message_body may be specified, to be appended to the request.
            &quot;&quot;&quot;
        self._buffer.extend((b&quot;&quot;, b&quot;&quot;))
        msg = b&quot;\r\n&quot;.join(self._buffer)
        del self._buffer[:]
&gt;       self.send(msg)

D:\Python360\lib\http\client.py:1026: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;http.client.HTTPConnection object at 0x061EF650&gt;
data = b&apos;POST /wd/hub/session HTTP/1.1\r\nAccept-Encoding: identity\r\nContent-Length: 196\r\nHost: localhost:4444\r\nAccept:...tion/json\r\nContent-Type: application/json;charset=UTF-8\r\nUser-Agent: Python http auth\r\nConnection: close\r\n\r\n&apos;

    def send(self, data):
        &quot;&quot;&quot;Send `data&apos; to the server.
            ``data`` can be a string object, a bytes object, an array object, a
            file-like object that supports a .read() method, or an iterable object.
            &quot;&quot;&quot;
    
        if self.sock is None:
            if self.auto_open:
&gt;               self.connect()

D:\Python360\lib\http\client.py:964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;http.client.HTTPConnection object at 0x061EF650&gt;

    def connect(self):
        &quot;&quot;&quot;Connect to the host and port specified in __init__.&quot;&quot;&quot;
        self.sock = self._create_connection(
&gt;           (self.host,self.port), self.timeout, self.source_address)

D:\Python360\lib\http\client.py:936: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

address = (&apos;localhost&apos;, 4444), timeout = &lt;object object at 0x027FAC70&gt;
source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        &quot;&quot;&quot;Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of &apos;&apos; or port 0 tells the OS to use the default.
        &quot;&quot;&quot;
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
                sock.connect(sa)
                return sock
    
            except error as _:
                err = _
                if sock is not None:
                    sock.close()
    
        if err is not None:
&gt;           raise err

D:\Python360\lib\socket.py:722: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

address = (&apos;localhost&apos;, 4444), timeout = &lt;object object at 0x027FAC70&gt;
source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        &quot;&quot;&quot;Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of &apos;&apos; or port 0 tells the OS to use the default.
        &quot;&quot;&quot;
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
&gt;               sock.connect(sa)
E               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it

D:\Python360\lib\socket.py:713: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = &lt;test_login.Test_Login object at 0x062079B0&gt;
method = &lt;bound method Test_Login.test_empty_password of &lt;test_login.Test_Login object at 0x062079B0&gt;&gt;

    def setup_method(self, method):
        self.current_method = method.__name__
        c = Config()
        self.config = c.prepare()
        browser_conf = self.config[&quot;browser&quot;]
&gt;       self.browser = browser.Browser(browser_conf, self.config)

base\FrameTestCase.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
browser.py:85: in __init__
    self.driver = SframeWebdriver(desired_capabilities=caps,command_executor=com_exe,browser_profile=profile)
framedriver.py:11: in __init__
    super(SframeWebdriver, self).__init__(**kwargs)
D:\Python360\lib\site-packages\selenium\webdriver\remote\webdriver.py:98: in __init__
    self.start_session(desired_capabilities, browser_profile)
D:\Python360\lib\site-packages\selenium\webdriver\remote\webdriver.py:188: in start_session
    response = self.execute(Command.NEW_SESSION, parameters)
D:\Python360\lib\site-packages\selenium\webdriver\remote\webdriver.py:250: in execute
    response = self.command_executor.execute(driver_command, params)
D:\Python360\lib\site-packages\selenium\webdriver\remote\remote_connection.py:464: in execute
    return self._request(command_info[0], url, body=data)
D:\Python360\lib\site-packages\selenium\webdriver\remote\remote_connection.py:526: in _request
    resp = opener.open(request, timeout=self._timeout)
D:\Python360\lib\urllib\request.py:526: in open
    response = self._open(req, data)
D:\Python360\lib\urllib\request.py:544: in _open
    &apos;_open&apos;, req)
D:\Python360\lib\urllib\request.py:504: in _call_chain
    result = func(*args)
D:\Python360\lib\urllib\request.py:1346: in http_open
    return self.do_open(http.client.HTTPConnection, req)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;urllib.request.HTTPHandler object at 0x061EF7F0&gt;
http_class = &lt;class &apos;http.client.HTTPConnection&apos;&gt;
req = &lt;selenium.webdriver.remote.remote_connection.Request object at 0x061EF390&gt;
http_conn_args = {}, host = &apos;localhost:4444&apos;
h = &lt;http.client.HTTPConnection object at 0x061EF650&gt;

    def do_open(self, http_class, req, **http_conn_args):
        &quot;&quot;&quot;Return an HTTPResponse object for the request, using http_class.
    
            http_class must implement the HTTPConnection API from http.client.
            &quot;&quot;&quot;
        host = req.host
        if not host:
            raise URLError(&apos;no host given&apos;)
    
        # will parse host:port
        h = http_class(host, timeout=req.timeout, **http_conn_args)
        h.set_debuglevel(self._debuglevel)
    
        headers = dict(req.unredirected_hdrs)
        headers.update(dict((k, v) for k, v in req.headers.items()
                            if k not in headers))
    
        # TODO(jhylton): Should this be redesigned to handle
        # persistent connections?
    
        # We want to make an HTTP/1.1 request, but the addinfourl
        # class isn&apos;t prepared to deal with a persistent connection.
        # It will try to read all remaining data from the socket,
        # which will block while the server waits for the next request.
        # So make sure the connection gets closed after the (only)
        # request.
        headers[&quot;Connection&quot;] = &quot;close&quot;
        headers = dict((name.title(), val) for name, val in headers.items())
    
        if req._tunnel_host:
            tunnel_headers = {}
            proxy_auth_hdr = &quot;Proxy-Authorization&quot;
            if proxy_auth_hdr in headers:
                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]
                # Proxy-Authorization should not be sent to origin
                # server.
                del headers[proxy_auth_hdr]
            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)
    
        try:
            try:
                h.request(req.get_method(), req.selector, req.data, headers,
                          encode_chunked=req.has_header(&apos;Transfer-encoding&apos;))
            except OSError as err: # timeout error
&gt;               raise URLError(err)
E               urllib.error.URLError: &lt;urlopen error [WinError 10061] No connection could be made because the target machine actively refused it&gt;

D:\Python360\lib\urllib\request.py:1320: URLError</error><system-out>{&apos;version&apos;: 1, &apos;disable_existing_loggers&apos;: False, &apos;formatters&apos;: {&apos;simple&apos;: {&apos;format&apos;: &apos;%(asctime)s - %(name)s - %(levelname)s - %(message)s&apos;}}, &apos;handlers&apos;: {&apos;console&apos;: {&apos;class&apos;: &apos;logging.StreamHandler&apos;, &apos;level&apos;: &apos;DEBUG&apos;, &apos;formatter&apos;: &apos;simple&apos;, &apos;stream&apos;: &apos;ext://sys.stdout&apos;}, &apos;info_file_handler&apos;: {&apos;class&apos;: &apos;logging.handlers.RotatingFileHandler&apos;, &apos;level&apos;: &apos;INFO&apos;, &apos;formatter&apos;: &apos;simple&apos;, &apos;filename&apos;: &apos;D:\\dec17\\output\\2017-12-19-15-29-34\\logs\\info.log&apos;, &apos;maxBytes&apos;: 10485760, &apos;backupCount&apos;: 20, &apos;encoding&apos;: &apos;utf8&apos;}, &apos;error_file_handler&apos;: {&apos;class&apos;: &apos;logging.handlers.RotatingFileHandler&apos;, &apos;level&apos;: &apos;ERROR&apos;, &apos;formatter&apos;: &apos;simple&apos;, &apos;filename&apos;: &apos;D:\\dec17\\output\\2017-12-19-15-29-34\\logs\\errors.log&apos;, &apos;maxBytes&apos;: 10485760, &apos;backupCount&apos;: 20, &apos;encoding&apos;: &apos;utf8&apos;}}, &apos;loggers&apos;: {&apos;my_module&apos;: {&apos;level&apos;: &apos;ERROR&apos;, &apos;handlers&apos;: [&apos;console&apos;], &apos;propagate&apos;: False}}, &apos;root&apos;: {&apos;level&apos;: &apos;INFO&apos;, &apos;handlers&apos;: [&apos;console&apos;, &apos;info_file_handler&apos;, &apos;error_file_handler&apos;]}}
browser init
{&apos;type&apos;: &apos;chrome&apos;, &apos;profiles&apos;: {&apos;darwin&apos;: None, &apos;profile&apos;: None}, &apos;grid filters&apos;: {&apos;platform&apos;: &apos;mac&apos;, &apos;version&apos;: &apos;23.0.1&apos;}}
2017-12-19 15:29:36,350 - selenium.webdriver.remote.remote_connection - INFO - Could not get IP address for host: localhost
</system-out></testcase><testcase classname="scripts.test_login.Test_Login" file="scripts\test_login.py" line="38" name="test_invalid_login" time="4.028722047805786"><error message="test setup failure">self = &lt;urllib.request.HTTPHandler object at 0x063A0510&gt;
http_class = &lt;class &apos;http.client.HTTPConnection&apos;&gt;
req = &lt;selenium.webdriver.remote.remote_connection.Request object at 0x063A0F30&gt;
http_conn_args = {}, host = &apos;localhost:4444&apos;
h = &lt;http.client.HTTPConnection object at 0x063A09D0&gt;

    def do_open(self, http_class, req, **http_conn_args):
        &quot;&quot;&quot;Return an HTTPResponse object for the request, using http_class.
    
            http_class must implement the HTTPConnection API from http.client.
            &quot;&quot;&quot;
        host = req.host
        if not host:
            raise URLError(&apos;no host given&apos;)
    
        # will parse host:port
        h = http_class(host, timeout=req.timeout, **http_conn_args)
        h.set_debuglevel(self._debuglevel)
    
        headers = dict(req.unredirected_hdrs)
        headers.update(dict((k, v) for k, v in req.headers.items()
                            if k not in headers))
    
        # TODO(jhylton): Should this be redesigned to handle
        # persistent connections?
    
        # We want to make an HTTP/1.1 request, but the addinfourl
        # class isn&apos;t prepared to deal with a persistent connection.
        # It will try to read all remaining data from the socket,
        # which will block while the server waits for the next request.
        # So make sure the connection gets closed after the (only)
        # request.
        headers[&quot;Connection&quot;] = &quot;close&quot;
        headers = dict((name.title(), val) for name, val in headers.items())
    
        if req._tunnel_host:
            tunnel_headers = {}
            proxy_auth_hdr = &quot;Proxy-Authorization&quot;
            if proxy_auth_hdr in headers:
                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]
                # Proxy-Authorization should not be sent to origin
                # server.
                del headers[proxy_auth_hdr]
            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)
    
        try:
            try:
                h.request(req.get_method(), req.selector, req.data, headers,
&gt;                         encode_chunked=req.has_header(&apos;Transfer-encoding&apos;))

D:\Python360\lib\urllib\request.py:1318: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;http.client.HTTPConnection object at 0x063A09D0&gt;, method = &apos;POST&apos;
url = &apos;/wd/hub/session&apos;
body = b&apos;{&quot;capabilities&quot;: {&quot;firstMatch&quot;: [], &quot;alwaysMatch&quot;: {&quot;browserName&quot;: &quot;chrome&quot;, &quot;version&quot;: &quot;&quot;, &quot;platform&quot;: &quot;ANY&quot;}}, &quot;desiredCapabilities&quot;: {&quot;browserName&quot;: &quot;chrome&quot;, &quot;version&quot;: &quot;&quot;, &quot;platform&quot;: &quot;ANY&quot;}}&apos;
headers = {&apos;Accept&apos;: &apos;application/json&apos;, &apos;Connection&apos;: &apos;close&apos;, &apos;Content-Length&apos;: &apos;196&apos;, &apos;Content-Type&apos;: &apos;application/json;charset=UTF-8&apos;, ...}

    def request(self, method, url, body=None, headers={}, *,
                encode_chunked=False):
        &quot;&quot;&quot;Send a complete request to the server.&quot;&quot;&quot;
&gt;       self._send_request(method, url, body, headers, encode_chunked)

D:\Python360\lib\http\client.py:1239: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;http.client.HTTPConnection object at 0x063A09D0&gt;, method = &apos;POST&apos;
url = &apos;/wd/hub/session&apos;
body = b&apos;{&quot;capabilities&quot;: {&quot;firstMatch&quot;: [], &quot;alwaysMatch&quot;: {&quot;browserName&quot;: &quot;chrome&quot;, &quot;version&quot;: &quot;&quot;, &quot;platform&quot;: &quot;ANY&quot;}}, &quot;desiredCapabilities&quot;: {&quot;browserName&quot;: &quot;chrome&quot;, &quot;version&quot;: &quot;&quot;, &quot;platform&quot;: &quot;ANY&quot;}}&apos;
headers = {&apos;Accept&apos;: &apos;application/json&apos;, &apos;Connection&apos;: &apos;close&apos;, &apos;Content-Length&apos;: &apos;196&apos;, &apos;Content-Type&apos;: &apos;application/json;charset=UTF-8&apos;, ...}
encode_chunked = False

    def _send_request(self, method, url, body, headers, encode_chunked):
        # Honor explicitly requested Host: and Accept-Encoding: headers.
        header_names = frozenset(k.lower() for k in headers)
        skips = {}
        if &apos;host&apos; in header_names:
            skips[&apos;skip_host&apos;] = 1
        if &apos;accept-encoding&apos; in header_names:
            skips[&apos;skip_accept_encoding&apos;] = 1
    
        self.putrequest(method, url, **skips)
    
        # chunked encoding will happen if HTTP/1.1 is used and either
        # the caller passes encode_chunked=True or the following
        # conditions hold:
        # 1. content-length has not been explicitly set
        # 2. the body is a file or iterable, but not a str or bytes-like
        # 3. Transfer-Encoding has NOT been explicitly set by the caller
    
        if &apos;content-length&apos; not in header_names:
            # only chunk body if not explicitly set for backwards
            # compatibility, assuming the client code is already handling the
            # chunking
            if &apos;transfer-encoding&apos; not in header_names:
                # if content-length cannot be automatically determined, fall
                # back to chunked encoding
                encode_chunked = False
                content_length = self._get_content_length(body, method)
                if content_length is None:
                    if body is not None:
                        if self.debuglevel &gt; 0:
                            print(&apos;Unable to determine size of %r&apos; % body)
                        encode_chunked = True
                        self.putheader(&apos;Transfer-Encoding&apos;, &apos;chunked&apos;)
                else:
                    self.putheader(&apos;Content-Length&apos;, str(content_length))
        else:
            encode_chunked = False
    
        for hdr, value in headers.items():
            self.putheader(hdr, value)
        if isinstance(body, str):
            # RFC 2616 Section 3.7.1 says that text default has a
            # default charset of iso-8859-1.
            body = _encode(body, &apos;body&apos;)
&gt;       self.endheaders(body, encode_chunked=encode_chunked)

D:\Python360\lib\http\client.py:1285: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;http.client.HTTPConnection object at 0x063A09D0&gt;
message_body = b&apos;{&quot;capabilities&quot;: {&quot;firstMatch&quot;: [], &quot;alwaysMatch&quot;: {&quot;browserName&quot;: &quot;chrome&quot;, &quot;version&quot;: &quot;&quot;, &quot;platform&quot;: &quot;ANY&quot;}}, &quot;desiredCapabilities&quot;: {&quot;browserName&quot;: &quot;chrome&quot;, &quot;version&quot;: &quot;&quot;, &quot;platform&quot;: &quot;ANY&quot;}}&apos;

    def endheaders(self, message_body=None, *, encode_chunked=False):
        &quot;&quot;&quot;Indicate that the last header line has been sent to the server.
    
            This method sends the request to the server.  The optional message_body
            argument can be used to pass a message body associated with the
            request.
            &quot;&quot;&quot;
        if self.__state == _CS_REQ_STARTED:
            self.__state = _CS_REQ_SENT
        else:
            raise CannotSendHeader()
&gt;       self._send_output(message_body, encode_chunked=encode_chunked)

D:\Python360\lib\http\client.py:1234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;http.client.HTTPConnection object at 0x063A09D0&gt;
message_body = b&apos;{&quot;capabilities&quot;: {&quot;firstMatch&quot;: [], &quot;alwaysMatch&quot;: {&quot;browserName&quot;: &quot;chrome&quot;, &quot;version&quot;: &quot;&quot;, &quot;platform&quot;: &quot;ANY&quot;}}, &quot;desiredCapabilities&quot;: {&quot;browserName&quot;: &quot;chrome&quot;, &quot;version&quot;: &quot;&quot;, &quot;platform&quot;: &quot;ANY&quot;}}&apos;
encode_chunked = False

    def _send_output(self, message_body=None, encode_chunked=False):
        &quot;&quot;&quot;Send the currently buffered request and clear the buffer.
    
            Appends an extra \\r\\n to the buffer.
            A message_body may be specified, to be appended to the request.
            &quot;&quot;&quot;
        self._buffer.extend((b&quot;&quot;, b&quot;&quot;))
        msg = b&quot;\r\n&quot;.join(self._buffer)
        del self._buffer[:]
&gt;       self.send(msg)

D:\Python360\lib\http\client.py:1026: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;http.client.HTTPConnection object at 0x063A09D0&gt;
data = b&apos;POST /wd/hub/session HTTP/1.1\r\nAccept-Encoding: identity\r\nContent-Length: 196\r\nHost: localhost:4444\r\nAccept:...tion/json\r\nContent-Type: application/json;charset=UTF-8\r\nUser-Agent: Python http auth\r\nConnection: close\r\n\r\n&apos;

    def send(self, data):
        &quot;&quot;&quot;Send `data&apos; to the server.
            ``data`` can be a string object, a bytes object, an array object, a
            file-like object that supports a .read() method, or an iterable object.
            &quot;&quot;&quot;
    
        if self.sock is None:
            if self.auto_open:
&gt;               self.connect()

D:\Python360\lib\http\client.py:964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;http.client.HTTPConnection object at 0x063A09D0&gt;

    def connect(self):
        &quot;&quot;&quot;Connect to the host and port specified in __init__.&quot;&quot;&quot;
        self.sock = self._create_connection(
&gt;           (self.host,self.port), self.timeout, self.source_address)

D:\Python360\lib\http\client.py:936: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

address = (&apos;localhost&apos;, 4444), timeout = &lt;object object at 0x027FAC70&gt;
source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        &quot;&quot;&quot;Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of &apos;&apos; or port 0 tells the OS to use the default.
        &quot;&quot;&quot;
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
                sock.connect(sa)
                return sock
    
            except error as _:
                err = _
                if sock is not None:
                    sock.close()
    
        if err is not None:
&gt;           raise err

D:\Python360\lib\socket.py:722: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

address = (&apos;localhost&apos;, 4444), timeout = &lt;object object at 0x027FAC70&gt;
source_address = None

    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
                          source_address=None):
        &quot;&quot;&quot;Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        A host of &apos;&apos; or port 0 tells the OS to use the default.
        &quot;&quot;&quot;
    
        host, port = address
        err = None
        for res in getaddrinfo(host, port, 0, SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket(af, socktype, proto)
                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
&gt;               sock.connect(sa)
E               ConnectionRefusedError: [WinError 10061] No connection could be made because the target machine actively refused it

D:\Python360\lib\socket.py:713: ConnectionRefusedError

During handling of the above exception, another exception occurred:

self = &lt;test_login.Test_Login object at 0x06374E90&gt;
method = &lt;bound method Test_Login.test_invalid_login of &lt;test_login.Test_Login object at 0x06374E90&gt;&gt;

    def setup_method(self, method):
        self.current_method = method.__name__
        c = Config()
        self.config = c.prepare()
        browser_conf = self.config[&quot;browser&quot;]
&gt;       self.browser = browser.Browser(browser_conf, self.config)

base\FrameTestCase.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
browser.py:85: in __init__
    self.driver = SframeWebdriver(desired_capabilities=caps,command_executor=com_exe,browser_profile=profile)
framedriver.py:11: in __init__
    super(SframeWebdriver, self).__init__(**kwargs)
D:\Python360\lib\site-packages\selenium\webdriver\remote\webdriver.py:98: in __init__
    self.start_session(desired_capabilities, browser_profile)
D:\Python360\lib\site-packages\selenium\webdriver\remote\webdriver.py:188: in start_session
    response = self.execute(Command.NEW_SESSION, parameters)
D:\Python360\lib\site-packages\selenium\webdriver\remote\webdriver.py:250: in execute
    response = self.command_executor.execute(driver_command, params)
D:\Python360\lib\site-packages\selenium\webdriver\remote\remote_connection.py:464: in execute
    return self._request(command_info[0], url, body=data)
D:\Python360\lib\site-packages\selenium\webdriver\remote\remote_connection.py:526: in _request
    resp = opener.open(request, timeout=self._timeout)
D:\Python360\lib\urllib\request.py:526: in open
    response = self._open(req, data)
D:\Python360\lib\urllib\request.py:544: in _open
    &apos;_open&apos;, req)
D:\Python360\lib\urllib\request.py:504: in _call_chain
    result = func(*args)
D:\Python360\lib\urllib\request.py:1346: in http_open
    return self.do_open(http.client.HTTPConnection, req)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;urllib.request.HTTPHandler object at 0x063A0510&gt;
http_class = &lt;class &apos;http.client.HTTPConnection&apos;&gt;
req = &lt;selenium.webdriver.remote.remote_connection.Request object at 0x063A0F30&gt;
http_conn_args = {}, host = &apos;localhost:4444&apos;
h = &lt;http.client.HTTPConnection object at 0x063A09D0&gt;

    def do_open(self, http_class, req, **http_conn_args):
        &quot;&quot;&quot;Return an HTTPResponse object for the request, using http_class.
    
            http_class must implement the HTTPConnection API from http.client.
            &quot;&quot;&quot;
        host = req.host
        if not host:
            raise URLError(&apos;no host given&apos;)
    
        # will parse host:port
        h = http_class(host, timeout=req.timeout, **http_conn_args)
        h.set_debuglevel(self._debuglevel)
    
        headers = dict(req.unredirected_hdrs)
        headers.update(dict((k, v) for k, v in req.headers.items()
                            if k not in headers))
    
        # TODO(jhylton): Should this be redesigned to handle
        # persistent connections?
    
        # We want to make an HTTP/1.1 request, but the addinfourl
        # class isn&apos;t prepared to deal with a persistent connection.
        # It will try to read all remaining data from the socket,
        # which will block while the server waits for the next request.
        # So make sure the connection gets closed after the (only)
        # request.
        headers[&quot;Connection&quot;] = &quot;close&quot;
        headers = dict((name.title(), val) for name, val in headers.items())
    
        if req._tunnel_host:
            tunnel_headers = {}
            proxy_auth_hdr = &quot;Proxy-Authorization&quot;
            if proxy_auth_hdr in headers:
                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]
                # Proxy-Authorization should not be sent to origin
                # server.
                del headers[proxy_auth_hdr]
            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)
    
        try:
            try:
                h.request(req.get_method(), req.selector, req.data, headers,
                          encode_chunked=req.has_header(&apos;Transfer-encoding&apos;))
            except OSError as err: # timeout error
&gt;               raise URLError(err)
E               urllib.error.URLError: &lt;urlopen error [WinError 10061] No connection could be made because the target machine actively refused it&gt;

D:\Python360\lib\urllib\request.py:1320: URLError</error><system-out>{&apos;version&apos;: 1, &apos;disable_existing_loggers&apos;: False, &apos;formatters&apos;: {&apos;simple&apos;: {&apos;format&apos;: &apos;%(asctime)s - %(name)s - %(levelname)s - %(message)s&apos;}}, &apos;handlers&apos;: {&apos;console&apos;: {&apos;class&apos;: &apos;logging.StreamHandler&apos;, &apos;level&apos;: &apos;DEBUG&apos;, &apos;formatter&apos;: &apos;simple&apos;, &apos;stream&apos;: &apos;ext://sys.stdout&apos;}, &apos;info_file_handler&apos;: {&apos;class&apos;: &apos;logging.handlers.RotatingFileHandler&apos;, &apos;level&apos;: &apos;INFO&apos;, &apos;formatter&apos;: &apos;simple&apos;, &apos;filename&apos;: &apos;D:\\dec17\\output\\2017-12-19-15-29-39\\logs\\info.log&apos;, &apos;maxBytes&apos;: 10485760, &apos;backupCount&apos;: 20, &apos;encoding&apos;: &apos;utf8&apos;}, &apos;error_file_handler&apos;: {&apos;class&apos;: &apos;logging.handlers.RotatingFileHandler&apos;, &apos;level&apos;: &apos;ERROR&apos;, &apos;formatter&apos;: &apos;simple&apos;, &apos;filename&apos;: &apos;D:\\dec17\\output\\2017-12-19-15-29-39\\logs\\errors.log&apos;, &apos;maxBytes&apos;: 10485760, &apos;backupCount&apos;: 20, &apos;encoding&apos;: &apos;utf8&apos;}}, &apos;loggers&apos;: {&apos;my_module&apos;: {&apos;level&apos;: &apos;ERROR&apos;, &apos;handlers&apos;: [&apos;console&apos;], &apos;propagate&apos;: False}}, &apos;root&apos;: {&apos;level&apos;: &apos;INFO&apos;, &apos;handlers&apos;: [&apos;console&apos;, &apos;info_file_handler&apos;, &apos;error_file_handler&apos;]}}
browser init
{&apos;type&apos;: &apos;chrome&apos;, &apos;profiles&apos;: {&apos;darwin&apos;: None, &apos;profile&apos;: None}, &apos;grid filters&apos;: {&apos;platform&apos;: &apos;mac&apos;, &apos;version&apos;: &apos;23.0.1&apos;}}
2017-12-19 15:29:41,077 - selenium.webdriver.remote.remote_connection - INFO - Could not get IP address for host: localhost
</system-out></testcase></testsuite>